#include "IIC.h"
#include "stm32f4xx.h"
#include "systick.h"
/**************************************************************************
* 函 数 名 : IIC_Start
* 功能说明 : 产生IIC起始信号
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : SCL为高电平期间，SDA由高电平向低电平的跳变。
****************************************************************************/ 
void IIC_Start(void)
{
	IIC_SDA = 0;
	IIC_SCL = 1;	//时钟线为高
	IIC_SDA = 1;	//数据线为高
	Delay_Us(5);	//保持，为了产生下沿的动作
	IIC_SDA = 0;	//SCL为高电平期间，拉低SDA，产生起止信号
	Delay_Us(5);
	IIC_SCL = 0;	//占用总线，准备发送数据
	Delay_Us(5);
}
/*********************************************************************************************************
* 函 数 名 : IIC_Wait_ACK
* 功能说明 : 作为发送方时，检测从机返回的应答信号
* 形    参 : 无
* 返 回 值 : 0：应答，1：非应答
* 备    注 : 
*********************************************************************************************************/ 
unsigned char IIC_Wait_ACK(void)
{
	unsigned char ErrorCounter = 0;
	IIC_SDA = 1;	//释放数据线
	IIC_SCL = 1;	//拉高SCL
	Delay_Us(5);
	while(IIC_SDAIN)			//SDA被拉低则认为从机给的应答信号
	{
		ErrorCounter++;
		if(ErrorCounter > 250)	//如果过了一段时间数据线还是为高，那么表示非应答信号
		{
			IIC_Stop();
			return 1;
		}
	}
	IIC_SCL = 0;	//拉低SCL，准备下一个数据的接受
	IIC_SDA=1;
	Delay_Us(5);
	return 0;
}
/*********************************************************************************************************
* 函 数 名 : IIC_Stop
* 功能说明 : 产生IIC结束信号
* 形    参 : 无
* 返 回 值 : 无
* 备    注 : SCL为高电平期间，SDA由低电平向高电平的跳变。
*********************************************************************************************************/ 
void IIC_Stop(void)
{
	IIC_SCL = 0;	//SCL为低电平时才能改变SDA的状态
	IIC_SDA = 0;	//拉低SDA，为产生上沿做准备
	IIC_SCL = 1;	//在SCL为高电平期间
Delay_Us(5);
	IIC_SDA = 1;	//SDA由低向高跳变
	Delay_Us(5);
	IIC_SDA=0;
}

/*************************************************
* 函 数 名 : IIC_ACK_NACK
* 功能说明 : 作为接收方时，每个字节（8bit）传输完成后的下一个时钟信号，发起应答或非应答信号
* 形    参 : ack：0应答，1非应答
* 返 回 值 : 
* 备    注 : 在SCL为高电平期间，SDA为低，则表示一个应答信号（ACK）；SDA为高，则表示一个非应答信号（NACK）。
*********************************************************************************************************/ 
void IIC_ACK_NACK(unsigned char ack)
{	
	IIC_SCL = 0;	//SCL为低电平时才能改变SDA的状态
	
	if(!ack)	IIC_SDA = 0;	//产生应答信号
	else 		IIC_SDA = 1;	//产生非应答信号
	Delay_Us(1);
	//Delay_Us(5);
	IIC_SCL = 1;	//拉高SCL，从机读取应答信号
	Delay_Us(5);
	IIC_SDA=1;
	IIC_SCL = 0;//拉低SCL，准备接收下一个数据
	Delay_Us(1);
	IIC_SDA=1;//????????????
}


void IIC_write_byte(u8 CMD)
{
	for(int i=0;i<8;i++)
	{
		IIC_SCL=0;//SCL为低电平时才能改变SDA的状态
		if(CMD&(0X80>>i)) IIC_SDA=1;
		else IIC_SDA=0;
		Delay_Us(2);
		IIC_SCL=1;        //释放时钟，且时钟高电平时数据不能改变电平
		Delay_Us(5);      //确保从机已经把数据读走
		
	}
	IIC_SCL=0; //拉低，准备下次数据的读取
}

u8 IIC_read_byte(void)
{
	u8 dat=0;
	for(int i=0;i<8;i++)
	{
		IIC_SCL=0;//SCL为低电平时才能改变SDA的状态
		Delay_Us(5);//确保从机把数据交出
		IIC_SCL=1; //不允许从机改变数据总线电平
		dat<<=1;   //空出最低位用于接收数据
		dat|=(u8)IIC_SDAIN;
		Delay_Us(2);
		IIC_SCL=0;
		
	}
	IIC_SCL=0; //拉低，准备下次数据的读取
	return dat;
}
